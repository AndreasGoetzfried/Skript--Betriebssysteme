\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{amsfonts}
\usepackage{tabularx}
\usepackage{mathtools}
\usepackage[ngerman]{babel}
\newcommand\norm[1]{\left\lVert#1\right\rVert}

\begin{document}
\begin{titlepage}
\centering
    \begin{figure}
    \centering
	    \includegraphics[width=90mm]{logo_lmu.jpg}
    \end{figure}
	{\scshape\LARGE Ludwig-Maximilians Universität \par}
	\vspace{1cm}
	{\scshape\Large Skript \par}
	\vspace{1.5cm}
	{\huge\bfseries Betriebssysteme\par}
	\vspace{2cm}
	{\Large\itshape Andreas Götzfried\par}
    \vfill
	    basierend auf\par
	    Prof. Dr. C.\textsc{Linnhoff-Popien}
    \vfill
	{\large \today\par}
\end{titlepage}
\tableofcontents{}

\newpage
\section{Einführung}
\subsection{Das Betriebssystem}
\subsubsection{Einordnung der Maschinensprache}
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/1_Kapitel/Hierarchie-der-Funktionen.png}
    \end{figure}
\subsubsection{Aufgaben des Betriebssystems}
    Ein Betriebssystem soll die Komplexität der Maschinensprache mindern. Das Betriebssystem ist eine \textbf{erweiterte Maschine}, die leichter zu programmieren ist als die darunter liegenden Schichten. Außerdem gilt es als \textbf{Ressourcenmanager}, indem es die vorhandenen Systemressourcen (Speicher, CPU, ...) verwaltet und zwischen den Anforderungen der Programme und diesen Ressourcen vermittelt. Für das \textbf{Multiplexing}, das Verteilen von Ressourcen auf mehrere Programme beziehungsweise Nutzer, kann ein \textbf{Time Multiplexing} gewählt werden, das die Ressourcen zeitlich verzahnt vollständig einem Programm zur Verfügung stellt (Prozessor), oder das \textbf{Space Multiplexing}, bei welchem sich mehrere Programme gleichzeitig die Ressourcen teilen (Hauptspeicher). Auch dient das Betriebssystem als \textbf{Kontrollinstanz} für jegliche Zugriffe und unterbindet unerlaubte Zugriffe.\newline
    \textbf{Bestandteile:}\newline
    Ein Betriebssystem besteht aus verschiedenen Programmen, die im Systemmodus(Kernel Mode) priorisiert laufen. Dazu zählen Gerätetreiber, Prozessmanager, Festermanager und andere.\newline
    \textbf{Systemaufrufe:}\newline
    Die Schnittstelle zwischen Anwendungsprogrammen und Betriebssystem wird durch Systemaufrufe definiert. 
\subsubsection{Geschichte der Betriebssysteme}
    \textbf{1. Generation: 1945 bis 1955 (Röhren und Klinkenfelder}\newline
    John von Neumann und Konrad Zuse waren Größen dieser Zeit, die riesige Apparate mit zehntausenden von Röhren und Taktzeiten in Sekunden als erste Rechner herstellten. Programme wurden über Klinkenfelder, später durch Lochkarten ersetzt, gesteckt oder in Maschinencode eingegeben. Programmiersprachen, Assemblersprachen und Betriebssysteme waren unbekannt.\newline
    \textbf{2. Generation: 1955 bis 1965 (Transistoren und Stapelsysteme}\newline
    Die Zuverlässigkeit von Systemen (Mainframe) wurde durch Transistoren erhöht, waren aber extrem teuer. Große Leerlaufzeiten durch die Programme, die durch Lochkarten eingegeben wurden und bis zum Ende durchlaufen mussten, entstanden. Deshalb wurde das Stapelverarbeitungssystem (Batchsystem) eingeführt, welches Aufträge sammelt und vom Mainframe eingelesen wurde. Ein Programmstapel begann mit einer \$JOB Karte, die die maximale Laufzeit, die Abrechnungsnummer und Name des Programmierer übertrug, dann folgte die \$FORTRAN Karte, die das Betriebssystem beauftragte, den Fortran Compiler zu laden, danach das zu übersetzende Programm und eine \$LOAD Karte, die das Programm lud, die \$RUN Karte veranlasste das Betriebssystem, das Programm zu bearbeiten, und mit der \$END Karte wurde die Programmbearbeitung beendet.\newline
    Erste Betriebssysteme waren FMS (Fortran Monitor System) und das IBSYS (IBM Betriebssystem). Diese Betriebssysteme unterbrachen bei jeder I/O-Aktion die CPU.\newline
    \textbf{3. Generation: 1965 bis 1980 (Integrierte Bauelemente und Multiprogramming}\newline
    Diese Generation verwendete integrierte Bauteile. Die Fortschritte waren das \textbf{Spooling}, das Jobs auf Vorrat einlesen und auf Festplatten speichern konnte, und der \textbf{Mehrprogrammbetrieb}, der Space Multiplexing verwendete.\newline
    Da man keinen Zugriff auf das Programm hatte, war ein Dialogbetrieb nötig, deshalb wurde das \textbf{Timesharing}-System (CTSS) entwickelt, welches jedem Benutzer über ein Terminal auf den Rechner zugreifen ließ. Dann wurde \textbf{MULTICS} (Multiplexed Information und Computing Service), ein Timesharing-System, das nur bei Bedarf die Kapazität nimmt, die es benötigt. Eine Einbenutzerversion \textbf{UNICS} (Uniplexed Information und Computing System) später \textbf{UNIX} (in C programmiert) wurde später vorgestellt.\newline
    \textbf{4. Generation: seit 1980 (PCs)}\newline
    Die Entwicklung von LSI (Large Scale Integration) Schaltkreisen erhöhte die Rechenleistung. Betriebssysteme waren \textbf{MS-DOS} (Microsoft Disk Operation System) und UNIX. zusätzlich wurde die \textbf{GUI} (Graphical User Interface) erfunden.\newline
    Betriebssysteme für Rechner lassen sich nun unterteilen:
    \begin{itemize}
        \item Netzwerk-Betriebssystem: Der Benutzer kennt mehrere Rechner mit eigenem Betriebssystem und kann sich gezielt auf diesen anmelden
        \item Verteiltes Betriebssystem: Soll wie ein Einprozessorsystem erscheinen, damit die Nutzer nicht wissen, wo Programme ablaufen und Daten liegen
    \end{itemize}
    \textbf{5. Generation: seit circa 2000 (mobile Betriebssysteme)}\newline
    Erstes Smartphone ist der Simon Personal Computer von IBM und BellSouth. Ab den iPhones wurde der Touch Screen populär. Anforderungen waren energiesparender und effizienter Zugriff wegen den begrenzten Ressourcen. Android basiert auf stark angepasstem Linux-Kernel mit besonders ressourcenschonender Programmierung. Die Sicherheit wird über eine Distributionskanal des Betriebssystems gewährleistet (PlayStore).
\subsubsection{Arten von Betriebssystemen}
    \begin{itemize}
        \item Mainframe-Betriebssystem: Optimiert auf gleichzeitig ablaufende Prozesse mit vielen I/O-Operationen
        \item Server-Betriebssystem: Kleine Webserver und Workstations
        \item Multiprozessor-Betriebssystem: Bei mehreren Prozessoren wird ein spezielles Betriebssystem benötigt, das die Verteilung der Aufgaben an die Prozessoren übernimmt
        \item PC-Betriebssystem: Generische Plattform für viele Anwendungen und Anforderungen
        \item Echtzeit-Betriebssystem: Steuerung von Maschinen. Weiches oder hartes System, bei geringer oder größerer Toleranz bei I/O-Operationen
        \item Embedded Betriebssystem: Für PDAs und mobile Endgeräte entwickelt; Kommunikationsschnittstellen sind wichtig
        \item Betriebssystem für Chipkarten: Mini-Betriebssystem, z.B. im Zusammenhang mit RFID-Technologie
    \end{itemize}
    
\newpage
\section{Prozesse}
\subsection{Programme und Unterprogramme}
\subsubsection{Vom Programm zum Maschinenprogramm}
    Ein zur Ausführung befindliches Programm ist ein Folge von Befehlen, die vom Prozessor ausgeführt werden. Um eine höhere Programmiersprache in Maschinenprogramm zu übersetzen, wird ein Compiler benötigt. Soll das Maschinenprogramm ausgeführt werden, bekommt er einen Speicherbereich zugewiesen mit genau so viel Speicherzellen wie Befehle im Programm, in welchen dann die Befehle kopiert werden.  
\subsubsection{Unterprogramme und Prozeduren}
    \textbf{Offenes Unterprogramm:}\newline
    Der Programmtext wird in das Hauptprogramm kopiert. Probleme beim Ändern des Unterprogramms und bei langen Unterprogrammen (Speicherplatz).\newline
    \textbf{Geschlossenes Unterprogramm (Prozedur):}\newline
    Das Programm wird über seine Anfangsadresse angesprungen und bei beenden über die Rückkehradresse verlassen. Announcements sind Prozeduren ohne Ergebnisparameter, Invocation mit. Auch rekursive Unterprogramme sind möglich.\newline
    Die Anfangsadresse wird mit dem Befehl CALL direkt angesprungen. RET bewirkt den Rücksprung. Die Prozedur kann Aufrufparameter und Rückgabewerte besitzen.\newline
    Die Informationen werden entweder durch ein Stack ausgetauscht, die eine beliebige Anzahl von Parametern definiert, oder durch spezielle Register, die in der Speicherhierarchie ganz oben stehen und geringste Zugriffszeiten haben.\newline
    \\
    \textbf{2.1.2.1 Die Befehle CALL und RET}\newline
    \begin{lstlisting}
        COMMAND JMP addr
        BEGIN 
            PC := addr;
        END
    \end{lstlisting}
    Der Befehl CALL unterscheidet sich vom Befehl JUMP durch die Sicherung der Rücksprungadresse. Entweder wird diese in einem Register gesichert oder auf einem Stack.
    \begin{lstlisting}
        COMMAND CALL addr
        BEGIN 
            RA := PC + 1 | PUSH (PC + 1);
            PC := addr;
        END
    \end{lstlisting}
    Entsprechend beim RET Befehl.
    \begin{lstlisting}
        COMMAND RET
        BEGIN 
            PC := RA | PC := POP;
        END
    \end{lstlisting}
    \\
    \textbf{2.1.2.2 Schema für Unterprogrammaufrufe}\newline
    Eine \textbf{Nested Procedure} ruft in ihrem eigenen Programm ein weiteres Unterprogramm auf, wobei immer wieder die RET-Adresse auf das aufrufende Programm weitergegeben werden muss.  
    \\
    \textbf{2.1.2.3 Module}\newline
    Module sind zum Beispiel Unterprogramme, Komponenten des Betriebssystems, Benutzerprogramme oder Prozesse. Zu einem Zeitpunkt kann nur ein Modul einem Rechnerkern zugeordnet werden. Die Zustände von Modulen, den Rechnerkernzustand, Speicherabbildungstabellen, Programmcode und Daten, müssen verwaltet werden. Eine Aktivierung eines Moduls kann durch einen Unterprogramm-/Prozeduraufruf, einem Systemaufruf oder einem Prozesswechsel erreicht werden.\newline
    \textbf{Server und Client:}\newline
    In verteilten Systemen stellen Module auch über Rechnergrenzen hinweg Dienste bereit.\newline
    \textbf{Dienst;}\newline
    Ein Dienst ist eine Funktion, die von einem Objekt an einer Schnittstelle angeboten wird.\newline
    \textbf{Entfernte Prozeduraufrufe:}\newline
    Da sich zwei Computer nicht den gleichen Speicher teilen, benötigt man entfernte Prozeduraufrufe, um Module aufrufen zu können.
\subsubsection{Realisierung eines Unterprogrammaufrufs}
    Die Modell-Maschine MI verfügt über die Register PC (Programmzähler), SP (Stack-Pointer) und R0 bis R14, wobei R12/R13 nicht frei genutzt werden dürfen, sondern die Ablageadresse des ersten Aufrufparameters und die Basisadresse des lokalen Datenraums des Unterprogramms erhalten. Außerdem besitzt die MI noch einen Kellerspeicher mit ausreichendem Speicherplatz. Die Adressen der Kellerzellen werden bei wachsendem Keller kleiner. Alle Speicherzellen sind 4 Bytes breit und können damit alle Maschinenbefehle zu 32-Bit-Wörtern kodiert.\newline
    Die Parameter des Unterprogrammaufrufs werden in umgekehrter Reihenfolge auf den Keller gelegt (lokaler Datenraum) und der Rückgabewert bekommt ebenfalls einen Kellerplatz. Die Register der Maschine MI sind Callee-saved, dass heißt das aufgerufene Unterprogramm trägt die Verantwortung dafür, dass der Kontext des Aufrufers nach dem Rücksprung unverändert dem Kontext vor dem Unterprogrammaufruf entspricht.\newline
    Befehle der MI sind:
    \begin{itemize}
        \item PUSH val: Legt Wert auf den Keller
        \item PUSH reg: Legt Inhalt des Registers auf Keller
        \item PUSHR: Sichert gesamen CPU-Register-Kontext (R0 bis R14)
        \item POP reg: Legt Inhalt der obersten Kellerzelle in Register
        \item POPR: Stellt gesamten Register-Kontext her
        \item MOVE addr, reg: Kopiert Adresse ins Register
        \item MOVE reg1, reg2: Kopiert Inhalt von Register 1 ins Register 2
        \item CALL addr: Sprung zu Adresse und Sicherung der Rücksprungadresse auf Keller
        \item RET: Rücksprung zum Aufrufer
    \end{itemize}
    Parameter können vom Hauptprogramm an das Unterprogramm und umgekehrt auf die Art Call by value (Wertübergabe) oder Call by referenz (Adressübergabe).
\subsubsection{Rekursive Prozeduraufrufe}
    Zu beachten ist hierbei, dass im i-ten Unterprogramm das Ergebnis in den lokalen Datenraum des (i-1)-ten Unterprogramms geschrieben wird. Daher ist es so wichtig, erst Speicherplatz für ein Ergebnis einzurichten und dann zu springen.
\subsection{Prozesse}
\subsubsection{Das Prozess-Konzept}
    \textbf{2.2.1.1 Grundlagen von Prozessen}\newline
    Im Vergleich zu Berechnungen durch den Prozess sind Operationen auf E/A-Geräten oft erheblich langsamer. Es soll verhindert werden, dass die CPU beim Warten auf das Ende von E/A-Operationen still steht.\newline
    Ein \textbf{Prozess} ist ein in Ausführung befindliches Maschinenprogramm mit aktuellem Wert des Programmzählers und den aktuellen Werten der Register und der Variablen.\newline
    Zum \textbf{Prozesskontext} gehören alle Informationen, die den aktuellen Ausführungszustand eines Prozessen genau beschreiben. Dazu zählt die CPU-Register-Belegungen und die Prozess-Status-Informationen. Hiermit lässt sich ein unterbrochener Prozess wieder fortsetzen.\newline
    Als \textbf{Image} eines Prozesses bezeichnet man die Gesamtheit der physischen Bestandteile eines Prozesses, also die Befehlsfolge und Kontext mit lokalen und globalen Variablen und Ausführungsstack. Hiermit lässt sich ein Prozess auf einem anderen Computer fortsetzen.\newline
    Beim \textbf{Uniprogramming} werden Prozesse sequenziell nacheinander, vollständig und ohne Unterbrechung ausgeführt.\newline
    Beim \textbf{Multiprogramming} wird zwischen mehreren Prozessen pseudo-parallel hin- und hergeschalten.\newline
    Beim \textbf{Multiprocessoring} stehen mehrere Prozessoren zur Verfügung, damit Prozesse echt-parallel ausgeführt werden können.\newline
    \\
    \textbf{2.2.1.2 Erzeugung von Prozessen}\newline
    Mit \textit{fork} wird eine identische Kopie (Kindprozess) des Prozesses unter Unix erzeugt. Unter MS DOS können Vater- und Kindprozesse nicht parallel ausgeführt werden. Hier wird der Vaterprozess suspendiert bis der Kindprozess fertig ist.\newline
    Durch \textbf{Dispatching} wird ein Rechnerkern an einen Prozess zugeordnet.\newline
    Die Ursachen für die Erzeugung eines Prozesses sind neue Stapelaufträge, die Benutzeranmeldung, ein Dienstleistungsprozess oder Kindprozesse.\newline
    In Unix sind alle Prozesse Nachkommen des \textit{init}-Prozesses.\newline
    Um einen Prozess zu erzeugen muss zuerst der Prozess einen Identifikator zugewiesen bekommen und mit dieser PID in die Prozesstabelle eingetragen. Dem Prozess wird dann Speicherplatz für das Prozess-Image zugeordnet. Danach wird der Prozesskontrollblock (PCB) initialisiert, die erforderlichen Links gesetzt und in eine Liste eingefügt werden (Ready bz. Ready, Suspend). Gegebenenfalls sind Datenstrukturen zu erweitern.\newline
    \\
    \textbf{2.2.1.3 Realisierung von Multiprogramming}\newline
    Aus Sicht des Prozessors ist es egal, welchen Code er ausführt und für ein Programm ist es nur wichtig, dass die Reihenfolge der Befehle eingehalten wird. Der \textbf{Dispatcher} ist ein Prozess, der einen Prozess unterbrechen und einem anderen Prozess dem Prozessor zuordnen kann.\newline
    \\
    \textbf{2.2.1.4 Das 2-Zustands-Prozessmodell}\newline
    Mit \textbf{Running} und \textbf{Not running} wird dieses einfache Prozessmodell beschrieben.
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/2-Zustandsmodell.png}
    \end{figure}
    Zwei Anforderungen an Information müssen abgeleitet werden können. Der aktuelle Zustand des Prozess muss beschreibbar sein und die Speicherinformationen des Prozesses müssen abrufbar sein.\newline
    Der \textbf{Scheduler} setzt die Strategie um, nach der entschieden wird, wann welcher Prozess als nächstes rechnen darf. Der \textbf{Dispatcher} übernimmt das Suspendieren und die Zuweisung der CPU an einen Prozess.\newline
    \\
    \textbf{2.2.1.5 Das 5-Zustands-Prozessmodell}\newline
    Hier kommen Ready, Blocked, New und Exit dazu und Not running ist überflüssig.
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/5-Zustandsmodell.png}
    \end{figure}
    Die Blocked Queue kann auch noch in priorisierte Queue eingeteilt werden.\newline
    \\
    \textbf{2.2.1.6 Das 7-Zustands-Prozessmodell}\newline
    Wenn der Hauptspeicher alle Prozesse in die Blocked Queue schiebt, steht kein Speicherplatz für weitere Prozesse zur Verfügung. Dieses Problem kann durch größeren Hauptspeicher oder Swapping gelöst werden.\newline
    \textbf{Swapping} lagert Teile eines blockierten Prozesses auf die Platte aus.\newline
    Der \textbf{Virtuelle Speicher} ist die Menge an Speicher, die dem Betriebssystem maximal zur Abbildung von Prozessen auf dem Hintergrundspeicher zur Verfügung stehen.\newline
    Das Swapping kann auch schon im 5-Zustands-Modell eingeführt werden.
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/5-Zustandsmodell-mit-Suspend.png}
    \end{figure}
    Wenn man bei diesem Modell sowohl bei den im Hauptspeicher enthaltenen als auch bei den ausgelagerten Prozessen zwischen blockierten und nicht blockierten unterscheidet, entsteht das 7-Zustands-Modell.
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/7-Zustandsmodell.png}
    \end{figure}
\subsubsection{Prozessbeschreibung}
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/Systemressourcen.png}
    \end{figure}
    \textbf{2.2.2.1 Kontrollstrukturen des Betriebssystems}\newline
    Die \textbf{Seitenrahmen (Frames)} beschreiben die Einteilung des Hauptspeichers in Speicherzellblöcken. Auch wird die Instruktionsfolge eines Prozesses in \textbf{Seiten} aufgeteilt.\newline
    Die \textbf{Speichertabellen} dienen dazu, den Überblick über den Haupt- und virtuellen Speicher zu behalten, wobei gleich ein Teil des Hauptspeichers für das Betriebssystem reserviert ist. Sie sind aufgebaut mit der Zuordnung der Seiten eines Prozesses zu den Frames, aus der Zuteilung des virtuellen Speichers zu den Prozessen und den Schutzattributen von Seiten und Frames.\newline
    Die \textbf{E/A-Tabellen} dienen zur Verwaltung der E/A-Geräte. Sie sind entweder vverfügbar oder einem Prozess zugeordnet, wobei hier das Betriebssystem den Status des Geräts kennt.\newline
    Die \textbf{Dateitabellen} enthalten Informationen über die Existenz von Dateien, über ihren Ort im Hintergrundspeicher, Status und Attributen. Falls seperates Dateisystem existiert, so kann ein Großteil dieser Informationen darin enthalten sein.\newline
    Die \textbf{Prozesstabellen} enthalten Informationen zur Verwaltung aller Prozesse.\newline
    \\
    \textbf{2.2.2.2 Prozesskontrollstrukturen}\newline
    Das Betriebssystem muss wissen, wo der Prozess gespeichert ist und welche Werte die relevanten Attribute besitzen.\newline
    Der Prozess kann lokalisiert werden, indem man die \textbf{dynamische Partitionierung (Segmentierung)} einsetzt, welche den Prozess als zusammenhängenden Block in den Speicherzellen ablegt, einen Teil dieser Daten in den Hauptspeicher geladen wird und bei Ausführung alles in den gesamten Prozess in den Hauptspeicher legt. Anders kann es bei einer \textbf{festen Partitionierung (Paging)} ablaufen. Hier wird der Speicher in feste Blöcke partitioniert und ein Prozess-Image in aneinander grenzenden Blöcken gespeichert. Der gesamte Prozess-Image befindet sich hierbei im Hintergrundspeicher und falls ein Teil benötigt wird, wird dieser in freie Frames des Hauptspeichers kopiert.\newline 
    Um die \textbf{Prozessattribute} zu kontollieren wird dies im Prozesskontrollblock (PCB) mit Prozessidentifikation, Prozesszustandsinformation und Prozesskontrollinformation gespeichert. Die \textbf{Prozessidentifikation} enthält den numerischen Identifikator (PID), den Identifikator des Elternprozesses und die ID des Eigentümers. Die \textbf{Prozesszustandsinformationen} beinhalten den Inhalt der Prozessregister und das Programmstatuswort, welches die Menge der Register mit Statusinformationen beschreibt. Die \textbf{Prozesskontrollinformation} besteht aus Scheduling- und Zustandsinformationen wie Prozesszustand, Priorität, Schedling-Strategie und Ereignisse, den Datenstrukturen (z.B. Referenz auf nächsten Prozess), Signalen oder Nachrichten zwischen Prozessen und zusätzlichen Informationen über Privilegien ddes Prozesses, Speichermanagement,  Eigentümerverhältnissen und ähnlichem.\newline
    Die Prozessstruktur im Hintergrundspeicher sieht wie folgt aus.\newline
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/Prozessstruktur_im_Hintergrundspeicher.png}
    \end{figure}
    \\
    \textbf{2.2.2.3 Zusammenfassung der Verwaltung und Beschreibung von Prozessen}\newline
    Das Betriebssystem entscheidet periodisch, ob ein Prozess angehalten werden soll und ein anderer aktiviert werden soll (Scheduler). Um die Arbeit eines suspendierten Prozesses wieder aufnehmen zu können, muss man einen Prozess beschreiben können.
\subsubsection{Prozesskontrolle}
    Es gibt den \textbf{Systemmodus (Kernel Mode)}, bei dem der Prozessor dem Betriebssystem zugeordnet ist, oder den \textbf{Benutzermodus (User Mode)}, bei dem der Prozesor einem Anwendungsprogramm zugeordnert ist. Der Systemmodus ist dabei privilegierter. Das \textbf{Programmstatuswort (PSW)} beschreibt, welcher Modus läuft (0 für Nutzermodus, 1 für Systemmodus).\newline
    Der \textbf{Betriebssystem-Kern} hat folgende Funktionen:
    \begin{itemize}
        \item Support Funktionen: Dienste, die von Nutzerprozessen in Anspruch genommen werden können
        \item Selbstverwaltungs Funktionen: Fehlermanagment, Konfigurationsmanagement, Abrechnungsmanagement, Leistungsmanagment, Sicherheitsmanagement
        \item E/A-Management: Verwaltung von Kanälen und Puffern
        \item Speichermanagement: Segemeniterung, Paging
        \item Prozessmanagement: Prozesserzeugung und Prozesswechsel
    \end{itemize}
    \textbf{2.2.3.1 Prozesswechsel (Kontext-Switch)}\newline
    Die Ursachen, um einen laufenden Prozess zu unterbrechen und einen neuen Prozess einzusetzen, können externe Ereignisse (I/O, timeout, ...), Traps (Ausnahmebedingung, Fehler, ...) oder ein Supervisor-Call (Betriebssystem Funktion) sein.\newline
    Um den Prozess erfolgreich zu wechseln muss zuerst der PCB den bisherigen Prozess aktualisiert und gesichert werden, dann muss der PCB den bisherigen Prozess in die Queue des Schedulers eingefügt werden. Anschließend wird ein anderer Prozess ausgewählt und ausgeführt. Zum Schluss wird der neue Prozess beim PCB wiederhergestellt und aktualisiert (Ausführungszustand auf "running").\newline
    \\
    \textbf{2.2.3.2 Unterbrechungen}\newline
    Eine Unterbrechung ist das Maschinenkonzept für die Behandlung nicht deterministischer Abläufe.\newline
    Man unterscheidet zwischen \textbf{externen Unterbrechungen (Interrupt)} bei Fehlern die außerhalb des Prozesses ausgelöst werden und \textbf{internen Unterbrechungen (Exception)}, welche vom ausgeführten Prozess selbst ausgelöst wird. Die \textbf{Unterbrechungsroutine (Interrupt Handler)} ist eine Komponente des Betriebssystems, die entscheidet, ob bei einer Unterbrechung der Prozess fortgesetzt werden kann oder in einen anderen Prozess gewechselt werden muss.\newline
    \\
    \textbf{2.2.3.3 Moduswechsel}\newline
    Die Schritte beim Moduswechsel beginnen mit der Aktualisierung und Sicherung der Zustandsinformationen des Prozesskontrollblocks, dann wird der eigentliche Moduswechsel durch Freigabe aller Privilegien durchgeführt und abschließend in die Unterbrechungsroutine gesprungen. Ein Moduswechsel ist schneller als ein Prozesswechsel, da die Zustandsinformationen nicht gesichert werden müssen.\newline
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/Prozess_Moduswechsel.png}
    \end{figure}
    \\
    \textbf{2.2.3.4 Konflikte bei Unterbrechungen}\newline
    Ursachen für Konflikte können sein, wenn während der Unterbrechungsbehandlung weitere Unterbrechungen auftreten, oder, wenn gleichzeitig mehrere Unterbrechungswünsche eintreffen.\newline
    Diese können gelöst werden, indem Prioritäten von Unterbrechungen eingeführt werden. Hierbei haben Benutzerprozesse die niedrigste Priorität, bei internen Unterbrechungen wird die Priorität des Prozesses übertragen, bie externen Unterbrechungen werden von 0 bis 31 Prioritäten festgelegt und falls die Priorität einer Unterbrechung höher ist als die Unterbrechungsbehandlung, die gerade läuft, wird diese zurückgestellt.\newline
    \\
    \textbf{2.2.3.5 Ausführung des Betriebssystems}\newline
    Ein Betriebssystem funktioniert wie eine gewöhnliche Computersoftware, das von einem Prozessor ausgeführt wird und muss oft die Kontrolle abgeben und bekommt dann vom Prozessor die Kontrolle wieder zurück. \newline
    Ein Konzept ist das des \textbf{seperaten Kern (Non-Process Kernel)}, welches in älternen Betriebssysteme vorkommt und der Kern des Betriebssystems außerhalb jeden PProzesses aufgeführt wird. Wir ein in Ausführung befindlicher Prozess unterbrochen, muss der Kontext gespeichert werden und die Kontrolle an den Betriebssystem-Kern übergeben. Das Betriebssystem verfügt über einen eigenen Speicher und eigenen Systemkeller zur Kontrolle von Prozeduraufrufe und entsprechenden Rücksprüngen. Ein anderes Konzpet ist das der \textbf{Integration in die Nutzerprozesse (Execution within User Process)}, welcher bei kleineren  Computern gebräuchlich ist und das gesamte Betriebssystem im Kontext jedes Nutzerprozesses ausgeführt wird. Ein Weiteres ist das es \textbf{prozessbasierten Betreibssystem (Process-based Operation System)}, bei welchem das Betriebssystem als eine Sammlung von Systemprozessen implementiert wird.   
\subsection{Threads}
    EinAls Zusammenfassung des Prozesses kann der Prozess als Eigentümer und Verwalter von Ressourcen oder als eine Einheit, die eine gewisse Aufgabe erledigt betrachtet werden. Die zweite Definition wird im folgeden als Thread bezeichnet.
\subsubsection{Multithreading}
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/multithread.png}
    \end{figure}
    Mit einem Prozess wird in der Multithread-Umgebung ein virtueller Adressraum, in dem das Prozessimage abgelegt wird, ein exclusiver Zuganz zum Prozessor, zu Prozessen, zu Dateien, zu E/A-Geräten und Zugriffsrechte assoziiert.\newline
    Innerhalb dieses Prozesses werden mehrere Threads ausgeführt, die dessen Adressraum nutzen. Ein Thread wird durch einen Zustand der Threadausführung, den Thread Kontext, den zwei Stacks für die Ausführung (user/kernel stack), etwas Speicherplatz und dem Zugriff auf Speicher und Ressourcen des Prozesses definiert.\newline
    Im \textbf{Singlethreading} werden die Prozessorregister vom Prozess kontrolliert. Zusätzlich wird beim \textbf{Multithreading} ein Kontrollblock (TCB) für jeden Thread zugeordnet.\newline
    Vorteile:
    \begin{itemize}
        \item weniger Zeit zur Generierung neuer Threads
        \item größere Kommunikation zwischen Threads (Sicherheitsproblem)
        \item weniger Wartezeit bei Blockierungen von einzelnen Threads
        \item weniger Zeit beim Kontextwechsel unter Threads
    \end{itemize}
    Wird ein Prozess geswappt, werden auch alle Threads mit ausgelagert. 
\subsubsection{Threadzustände}
    \begin{figure}[h]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/threadzustaende.png}
    \end{figure}
\subsubsection{User-Level-Threads (ULT)}
    Bei diesen Threads ist das Threadmanagement Aufgabe der Anwendung und das Betriebssystem kennt diese Threads nicht. Threadbibliotheken ermöglichen die Programmierung von Multithread-Anwendungen. Diese erhalten Code für die Generierung und Terminierung, zur Nachrichten- und Datenübermittlung, zum Scheduling und zum Sichern und Löschen von Threadkontexten.\newline
    Läuft ein Thread in einem Prozess kann in diesem jederzeit ein neuer Prozess generiert werden.\newline
    Vorteile:
    \begin{itemize}
        \item Keine Privilegien für die Threaderzeugung/Threadwechsel
        \item Scheduling kann auf Threadebene realisiert werden
        \item Jedes Betriebssystem kann dieses machen
    \end{itemize}
    Nachteile:
    \begin{itemize}
        \item wird ein Thread blockiert, wird der gesamte Prozess blockiert (Lösung: Jacketings)
        \item keine parallele Ausführung von Threads (Lösung: seperate Prozesse)
    \end{itemize}
\subsubsection{Kernel-Level-Threads (KLT)}
    Dieses Thread Konzept wird vom Betriebssystem-Kern ausgeführt. Vorteile sind die schnelle Erzeugung, Terminiertung und Wechsel von KLTs, verschiedene Prozessoren können für unterschiedliche Threads desselben Prozesses benutzt werden und bei Blockade kann die Kontrolle einem anderen Thread desselben Prozesses übergeben werden. Ein Nachteil ist bei der Kontrollübergabe an einen anderen Thread, dass ein Moduswechsel erforderlich ist und es deshalb zu verlangsamung kommen kann.
\subsubsection{Kombinierte Konzepte}
     Um beide Threadkonzepte zu verwenden, wurden kombinierte Betriebssysteme entwickelt. Ziel ist es dabei, die Vorteile beider Konzepte zu kombinieren und die Nachteile zu minimieren. Im folgenden werden die Verhältnis Threads:Prozesse näher dargestellt.
     \begin{itemize}
         \item 1:1 jedem Thread ist ein Prozess zugeordnet (ältere UNIX-Versionen)
         \item n:1 einem Prozess sind mehrere Threads zugeordnet (Windows NT, Solaris)
         \item 1:n ein Thread kann von einer Prozessumgebung zu anderen migriert werden (Clouds Operating System)
         \item n:m kombiniert n:1 und 1:n Ansätze (Operating System TRIX)
     \end{itemize} 
\subsubsection{Andere Formen paralleler Abläufe}
    \begin{figure}[H]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/paralleke_prozessoren.png}
    \end{figure}
    Um Parallelität zu ermöglichen, gibt es die Ansätze Master/Slave Architektur, das Symmetrische Multiprocesseing (SMP) und das Clustering.
    \begin{figure}[H]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/parallel_prozessoren_bild.png}
    \end{figure}
    Der SMP-Ansatz hat die Vorteile Verteilter Systeme, aber es muss gewährleistet werden, dass zwei Prozessoren nie denselbsen Prozess auswählen. Beim SMP hat jeder Prozessor seine eigene Kontrolleinheit, ALU und Register. Jeder Prozess hat Zugriff zum gemeinsamen Hauptspeicher und den E/A-Geräten.
    \begin{figure}[H]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/smp.png}
    \end{figure}
\subsection{Scheduling}
\subsubsection{Das Prinzip des Schedulings}
    Scheduling wird notwendig, sobald mindestens ein Prozess im Zustand \textit{running} und mehrere Prozesse im Zustand \textit{ready} sind.
    \textbf{2.4.1.1 Varianten des Schedulings}\newline
    Beim \textbf{nicht preemptiven Scheduling} handelt es sich um eine Art, die beim Stapelbetrieb eingesetzt wird. Deshalb wurde es meist in älternen Systemen benutzt. Das \textbf{preemptive Scheduling} unterbricht jederzeit Prozesse, so dass ein anderer Prozess zur Ausführung kommen kann.\newline
    \\
    \textbf{2.4.1.2 Anforderung an einen Scheduling-Algorithmus}\newline
    Es werden drei Klassen von Systeme unterschieden. Das Batch-System (Stapelverarbeitungssystem), das interaktive System und das Echtzeitsyste.\newline
    Anforderungen, die allen Systemen gemein sind, sind:
    \begin{itemize}
        \item Fairness: gerechter Anteil an der Prozessorzeit
        \item Policy Enforcement: keine Ausnahmen
        \item Balance: alle Teile des Systems sind ausgelastet
        \item Datensicherheit: kein Verlust von Daten
        \item Skalierbarkeit: mittlere Leistung wird beibehalten
        \item Effizienz: Prozessor vollständig ausgelastet
    \end{itemize}
    Beim Batch-System gilt zusätzlich noch der Durchsatz (Maximierung der Prozesse pro Zeiteinheit), die Verweildauer (Minimierung der Zeit vom Start bis Beendigung) und die Prozessorauslastung (maximale Auslastung der CPU). Das Interaktive System benötigt zusätzlich noch minimale Antwortzeit, Verhältnismäßigkeit (Erwartungen des Benutzers müssen berücksichtigt werden) und maximale Anzahl interagierenden Nutzer (Interaktion). Beim Echtzeitsystem sind Sollzeitpunkte (Timeouts) und Vorhersagbarkeit weitere Anforderungen.\newline
    Meist werden die Ready-Queues in Prioritätenlisten aufgesplittet. Damit Prozesse mit niedrigen Priotitäten nicht verhungern, kann sich die Priotitäten durch die Zeit in der Queue ändern.\newline
    Beim \textbf{nonpreemptiven Modus} wird der Prozess bis zur Terminierung oder durch Warten fortgesetzt. Anders beim \textbf{preemptiven Modus}, bei welchen Prozesse aufgrund eines neuen Prozesses, ein höher priorisierten Prozess oder Timeouts terminiert werden.\newline
    \\
    \textbf{2.4.1.3 Scheduling vs. Dispatching}\newline
    Ein Scheduler nimmt die Auswahl eines rechenbereiten Prozesses und die Unterbrechung des aktuell abgearbeiteten Prozesses. Der Dispatcher setzt diesen Kontextwechsel um.
\subsubsection{Scheduling-Algorithmen}
    \textbf{2.4.2.1 Begriffe}\newline
    \begin{itemize}
        \item Ankunftszeit: Zeitpunkt ab Existenz eines Prozesses
        \item Startzeit: Zeitpunkt der ersten Zuweisung an den Prozessor
        \item Verweildauer: Zeitdifferenz zwischen Ankunftszeit und Terminierung
        \item Antwortzeit: Zeitspanne zwischen Eingabe und Beginn des Empfange seiner Antwort
        \item Bedienzeit: Zeit im Zustand \textit{running} 
        \item Wartezeit: Zeit im Zustand \textit{not running}
        \item Beendigungszeit: Zeitpunkt der Terminierung
        \item Normalisierte Verweildauer: Quotient Verweiildauer zu Bedienzeit (sollte bei 1 liegen)
    \end{itemize}\newline
    \\
    \textbf{2.4.2.2 Nicht-preemptive Scheduling-Algorithmus}\newline
    Es gibt das Prinzip \textbf{First Come First Serve (FCFS)}, welches aber schnell blockiert werden kann. Vorteile sind die einfache Implementierung und die Fairness.\newline
    Ein anderes Prinzip ist das \textbf{Shortest Process Next (SPN)/Shortest Job First (SJF)}, was zum Problem des Verhungerns längerer Prozesse führen kann und man muss den Mittelwert ähnlicher abgearbeiteten Aufträge berechnen, um die erwartete Abarbeitungsdauer zu kennen. Ein Vorteil ist die günstige Verweildauer.\newline
    \\
    \textbf{2.4.2.3 Preemptive Scheduling-Algorithmus}\newline
    Um wichtigere Jobs einzuschieben und die Verweildauer und Antwortzeit zu reduzieren ist diese Art der Algorithmen optimal. Diese ermöglichen auch mehr Flexibilität können aber auch zu Inkonsistenzen führen, wenn Jobs für andere Jobs benötigt werden.\newline
    Das Pendant zum SJF ist beim preemptiven Scheduling das Prinzip \textbf{Shortest Remaining Processing Time (SRPT)}. Ein anderes Prinzip ist \textbf{Round Robin}, wobei mit Timeouts gearbeitet wird. Die mittlere Verweildauer ist besser als FCFS, aber schlechter als SJF und SRPT. Dennoch ist RR fair (kein Verhungern) und praktisch implemetierbar, dazu muss aber der Timeout optimal gewählt werden. Bei RR wird ein kürzerer Prozess schneller abgearbeitet.\newline
    \\
    \textbf{2.4.2.4 Priority Scheduling (PS)}\newline
    Beim Priority Scheduling wird der höherpriorisierte Prozess zuerst ausgewählt mit den Vorteilen, dass wichtige Prozesse bevorzugt werden und der praktischen Implementierung. Nachteile sind das Verhungern von niedrig priorisierten Prozessen und die relativ schlechte mittlere Verweildauer.\newline
    \\
    \textbf{2.4.2.5 Multilevel Feedback Queueing}\newline
    Bei diesem Algorithmus wird sowohl mit Prioritätsklassen als auch mit Zeitscheiben gearbeitet. Bei der Inanspruchnahme der gesamten zugewiesenen Zeit wird der Prozess unterbrochen und an das Ende der nächst niedrigeren Queue gesetzt. Wenn der Prozess den Prozessort freiwillig verlässt, landet dieser wieder in der selben Queue. Die Queue werden im RR-Verfahren abgearbeitet.  
\subsubsection{Prozesswechsel}
    Der Dispatcher realisiert diesen Kontextwechsel des Prozessors.
\subsubsection{Arten des Schedulings}
    Es werden \textbf{Short/Medium/Long Term Scheduling} unterschieden.
    \begin{figure}[H]
        \centering
	    \includegraphics[width=90mm]{Skizzen/2_Kapitel/arten_von_scheduling.png}
    \end{figure}

\newpage
\section{Multiprocessing}
\subsection{Deadlocks bei Prozessen}
\subsubsection{Motivation der Deadlocks anhand zweier Beispiele}
\subsubsection{Das Prinzip der Deadlocks}
\subsubsection{Deadlock Prevention}
\subsection{Prozesskoordination}
\subsubsection{Nebenläufigkeit von Prozessen}
\subsubsection{Kritische Bereiche}
\subsubsection{Wechselseitiger Ausschluss}
\subsubsection{Semaphore}
\subsubsection{Monitore}
\subsubsection{Message Passing}

\newpage
\section{Ressourcenverwaltung}
\subsection{Speicher}
\subsubsection{Speicherverwaltung}
\subsubsection{Speicherpartitionierung}
\subsubsection{Virtueller Speicher}
\subsubsection{Paging}
\subsubsection{Segmentierungsstrategien}
\subsection{E/A Verwaltung}
\subsubsection{Klassifizierung von E/A-Geräten}
\subsubsection{E/A Techniken}

\newpage
\section{Interprozesskommunikation}
\subsection{Lokale Interprozesskommunikation}
\subsubsection{Grundlagen des Nachrichtenaustauschs}
\subsubsection{Pipes}
\subsubsection{FIFOs}
\subsubsection{Stream Pipes}
\subsubsection{Sockets}
\subsection{Verteilte Systeme}
\subsubsection{Einführung in Verteilte Systeme}
\subsubsection{Kommunikation in Verteilte Systeme}
\end{document}